# 浏览器

# 浏览器的进程和线程

## 1.浏览器是多进程的
浏览器是多进程的，打开浏览器的一个页面就可以看到浏览器打开的多个进程，包括 network 、GPU、标签、浏览器主进程

下面介绍一下进程和线程的关系
### 线程和进程的关系
线程：线程是用来处理任务的
进程：进程用来启动和管理线程，一个进程就是一个程序的运行实例

### 进程和线程的4个特点
1. 进程中的任一线程崩溃就会导致进程的崩溃
2. 线程之间共享进程的数据
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存
4. 进程之间的内容相互隔离

### 目前浏览器的各个进程
1. 浏览器进程
2. 渲染进程
3. GPU 进程
4. 网络进程
5. 插件进程

浏览器的多进程确实提升了浏览器的稳定性、流畅性和安全性，但也不可避免的带来了一些问题
1. 更高的资源占用
2. 更复杂的体系架构

## 2.从输入URL到页面展示
1. 页面资源请求过程，浏览器进程会通过进程间通信把URL请求发送到网络进程，网络进程会去查询本地是否有缓存了该资源。

2. DNS解析 获取IP和端口

3. 进行TCP链接

4. 发送HTTP请求

5. 服务端返回数据

5. 网络进程根据服务端返回的数据进行处理
#### 重定向
如果网络进程解析到的响应头状态码是 301 或 302 那么就会根据响应头的 Location 字段进行重定向
#### 响应数据类型进行处理
浏览器根据 Content-Type 的值来决定显示的内容

6. 准备渲染进程进行渲染

7. 浏览器进程会通知渲染进程进行文档提交，渲染进程就会和网络进程建立管道，数据传输完成后将会通知浏览器进程传输完成

8. 渲染进程准备渲染

## process-per-site-instance
如果从一个页面打开了另一个新 页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程


## 页面渲染
### 构建dom树
因为浏览器无法识别HTML所以要将HTML转化为dom树

### 转化CSS
1. 把 css 转化为浏览器能够理解的结构 也就是styleSheets
2. 转化样式表中的属性，使其标准化
3. 计算出 DOM 树每个节点的具体样式。这就涉及到 CSS 的继承规则和层叠规则了。

### 布局阶段
1. 创建布局树，构建一颗只包含可见元素布局树
2. 布局计算

### 分层
因为页面中有很多复杂效果，渲染引擎还需为特定的节点生成专用的图层，生成一颗对应的图层树
不是每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就是从属于父节点的图层
1. 拥有图层上下文属性的元素会被提升为单独的一层
2. 需要剪裁的地方也会被创建为图层
::tip
层叠上下文
::

### 栅格化操作
当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程。合成线程会将图层划分为图块。合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执 行的。所谓栅格化，是指将图块转换为位图
### 合成和显示
一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”， 然后将该命令提交给浏览器进程
### 渲染流水线总结
1. 渲染进程将 HTML 内容转换为能够读懂的DOM 树结构
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图
7. 合成线程发送绘制图块命令DrawQuad给浏览器进程
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上

DOM->Style->Layout->Layer->Paint
### 重排
例如修改了元素的高度，那么浏览器就会触发重新布局，解析之后的一系列流程，这个阶段叫做重排，重排需要更新完整的渲染流水线，所以开销也是最大
### 重绘
例如修改了元素的背景颜色，布局阶段将不会被执行，将会直接进入绘制阶段
### 合成阶段
更高一个既不要布局也不要绘制的属性，渲染引擎将会跳过布局和绘制，只执行后续的合成阶段，这个过程叫合成。如transform

## javascript 执行上下文
### 变量提升
javascript在执行之前会进行编译，在编译过程中会变量提升
### 代码的执行流程
先编译后执行
### 思考题
``` js
showName()
var showName = function() {
  console.log(2)
}
function showName() {
  console.log(1)
}
```
执行结果是 1
解释
1. 如果是同名函数，Javascript编译阶段会选择最后声明的那个
2. 如归变量和函数同名，那么在编译阶段，变量的声明会被忽略

## javascript 的块级作用域
作用域就是变量和函数的可访问范围
### var 的缺陷
1. 变量容易在不被察觉的情况下被覆盖掉
2. 本应销毁的变量没有被销毁
### let 和 const
站在执行上下文的角度来看javascript 是如何实现块级作用域的
作用域块中通过 let 声明的变量，会被存放在 词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量
在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用 域块后，就会把该作用域块内部的变量压到栈顶;当作用域执行完成之后，该作用域的信息 就会从栈顶弹出，这就是词法环境的结构

## 内存机制
### 内存空间
1. 代码空间
2. 栈空间
3. 堆空间

原始数据放在栈空间里 引用类型的数据放在堆中

### 垃圾回收
#### 栈中的数据
切换执行上下文的过程进行垃圾回收
#### 堆中的数据
就需要用到 javascript 中的垃圾回收器了

代际假说有2个特点：
大部分对象在内存中存在的时间很短
第二个是不死的对象，会活得更久。

V8引擎将堆分为新生代和老生代，新生代中存放的是生存时间短的对象，老生代中存放的是生存时间久的对象

副垃圾回收器，主要负责新生代的垃圾回收
主垃圾回收器，主要负责老生代的垃圾回收

不论什么类型的垃圾回收器，它们都有一套共同的执行流程。
1. 记空间中活动对象和非活动对象
2. 回收非活动对象所占据的内存
3. 内存整理

#### 副垃圾回收器
多数小的对象都会被分配到新生区，区域虽然不大，但是垃圾回收还是比较频繁的。

新生代中用Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域

新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作

在垃圾回收过程中，首先要对对象区域中的垃圾做标记;标记完成之后，就进入垃圾清理阶 段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

种角色翻转的操 作还能让新生代中的这两块区域无限重复使用下去。

JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

#### 主垃圾回收器
老生区中的垃圾回收，老生区中的对象有两个特点：
1. 对象占用空间大，
2. 对象存活时间长

标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历 过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据

标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片

而碎片过多会导致大对象无法分配到足够的连续内 存，于是又产生了另外一种算法——标记 - 整理

#### 全停顿
的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停 顿

 将标记过程分为一个个的子标记过程，同时 让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称 为增量标记


