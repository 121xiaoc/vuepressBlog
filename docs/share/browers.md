# 浏览器

# 浏览器的进程和线程

## 1.浏览器是多进程的
浏览器是多进程的，打开浏览器的一个页面就可以看到浏览器打开的多个进程，包括 network 、GPU、标签、浏览器主进程

下面介绍一下进程和线程的关系
### 线程和进程的关系
线程：线程是用来处理任务的
进程：进程用来启动和管理线程，一个进程就是一个程序的运行实例

### 进程和线程的4个特点
1. 进程中的任一线程崩溃就会导致进程的崩溃
2. 线程之间共享进程的数据
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存
4. 进程之间的内容相互隔离

### 目前浏览器的各个进程
1. 浏览器进程
2. 渲染进程
3. GPU 进程
4. 网络进程
5. 插件进程

浏览器的多进程确实提升了浏览器的稳定性、流畅性和安全性，但也不可避免的带来了一些问题
1. 更高的资源占用
2. 更复杂的体系架构

## 2.从输入URL到页面展示
1. 页面资源请求过程，浏览器进程会通过进程间通信把URL请求发送到网络进程，网络进程会去查询本地是否有缓存了该资源。

2. DNS解析 获取IP和端口

3. 进行TCP链接

4. 发送HTTP请求

5. 服务端返回数据

5. 网络进程根据服务端返回的数据进行处理
#### 重定向
如果网络进程解析到的响应头状态码是 301 或 302 那么就会根据响应头的 Location 字段进行重定向
#### 响应数据类型进行处理
浏览器根据 Content-Type 的值来决定显示的内容

6. 准备渲染进程进行渲染

7. 浏览器进程会通知渲染进程进行文档提交，渲染进程就会和网络进程建立管道，数据传输完成后将会通知浏览器进程传输完成

8. 渲染进程准备渲染

## process-per-site-instance
如果从一个页面打开了另一个新 页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程


## 页面渲染
### 构建dom树
因为浏览器无法识别HTML所以要将HTML转化为dom树

### 转化CSS
1. 把 css 转化为浏览器能够理解的结构 也就是styleSheets
2. 转化样式表中的属性，使其标准化
3. 计算出 DOM 树每个节点的具体样式。这就涉及到 CSS 的继承规则和层叠规则了。

### 布局阶段
1. 创建布局树，构建一颗只包含可见元素布局树
2. 布局计算

### 分层
因为页面中有很多复杂效果，渲染引擎还需为特定的节点生成专用的图层，生成一颗对应的图层树
不是每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就是从属于父节点的图层
1. 拥有图层上下文属性的元素会被提升为单独的一层
2. 需要剪裁的地方也会被创建为图层
::tip
层叠上下文
::

### 栅格化操作
当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程。合成线程会将图层划分为图块。合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执 行的。所谓栅格化，是指将图块转换为位图
### 合成和显示
一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”， 然后将该命令提交给浏览器进程
### 渲染流水线总结
1. 渲染进程将 HTML 内容转换为能够读懂的DOM 树结构
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图
7. 合成线程发送绘制图块命令DrawQuad给浏览器进程
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上

DOM->Style->Layout->Layer->Paint
### 重排
例如修改了元素的高度，那么浏览器就会触发重新布局，解析之后的一系列流程，这个阶段叫做重排，重排需要更新完整的渲染流水线，所以开销也是最大
### 重绘
例如修改了元素的背景颜色，布局阶段将不会被执行，将会直接进入绘制阶段
### 合成阶段
更高一个既不要布局也不要绘制的属性，渲染引擎将会跳过布局和绘制，只执行后续的合成阶段，这个过程叫合成。如transform

## javascript 执行上下文
### 变量提升
javascript在执行之前会进行编译，在编译过程中会变量提升
### 代码的执行流程
先编译后执行
### 思考题
``` js
showName()
var showName = function() {
  console.log(2)
}
function showName() {
  console.log(1)
}
```
执行结果是 1
解释
1. 如果是同名函数，Javascript编译阶段会选择最后声明的那个
2. 如归变量和函数同名，那么在编译阶段，变量的声明会被忽略








